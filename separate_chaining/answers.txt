With 48 positions hashes  available values are 4 like the example and there are not collisions going the hashes to the linked linked_list
With 12 hashes values are 2 like the example and there are  collisions going the hashes to the linked linked_list

With 48 posiosions:

hash = SeparateChaining.new(48)
hash['Eduardo'] = 'guncho'
hash['Wanceslao'] = 'carlos'
hash['Mario'] = 'daniel'
hash['Alejandro'] = 'Jonathan'
hash.print

eduardos-MBP:separate_chaining eduardolowensohn$ ruby separate_chaining.rb
#<LinkedList:0x00007f9549900930>
-
-
-
-
-
-
-
-
-
-
-
-
#<LinkedList:0x00007f9549900db8>
-
-
-
-
-
-
-
-
-
-
#<LinkedList:0x00007f9549900c00>
-
-
-
-
-
-
-
-
-
-
-
#<LinkedList:0x00007f9549900f48>
-
-
-
-
-
-
-
-
-
-
-
With 12 positions:

hash = SeparateChaining.new(12)
hash['Eduardo'] = 'guncho'
hash['Wanceslao'] = 'carlos'
hash['Mario'] = 'daniel'
hash['Alejandro'] = 'Jonathan'
hash.print

eduardos-MBP:separate_chaining eduardolowensohn$ ruby separate_chaining.rb
#<LinkedList:0x00007fd2ee969060>
#<LinkedList:0x00007fd2ee968ed0>
-
-
-
-
-
-
-
-
-
-
eduardos-MBP:separate_chaining eduardolowensohn$ 


eduardos-MBP:separate_chaining eduardolowensohn$ ruby print.rb
#<LinkedList:0x00007fe4e183e078>
#<LinkedList:0x00007fe4e183dec0>
-
-
-
-
-
-
-
-
-
-
insert hash { "Star Wars: The Phantom Menace", "Number One" }
#<LinkedList:0x00007fe4e183cfc0>
-
-
-
-
-
load factor: 0.16666666666666666

insert hash { "Star Wars: Attack of the Clones", "Number Two" }
#<LinkedList:0x00007fe4e183cfc0>
-
-
#<LinkedList:0x00007fe4e183c958>
-
-
load factor: 0.3333333333333333

insert hash { "Star Wars: Revenge of the Sith", "Number Three" }
#<LinkedList:0x00007fe4e183cfc0>
-
-
#<LinkedList:0x00007fe4e183c958>
-
#<LinkedList:0x00007fe4e183c318>
load factor: 0.5

insert hash { "Star Wars: A New Hope", "Number Four" }
#<LinkedList:0x00007fe4e183cfc0>
-
-
#<LinkedList:0x00007fe4e183c958>
#<LinkedList:0x00007fe4e1837d18>
#<LinkedList:0x00007fe4e183c318>
load factor: 0.6666666666666666

insert hash { "Star Wars: The Empire Strikes Back", "Number Five" }
-
-
#<LinkedList:0x00007fe4e1837458>
#<LinkedList:0x00007fe4e1837390>
#<LinkedList:0x00007fe4e18372c8>
-
#<LinkedList:0x00007fe4e1837548>
-
-
-
-
#<LinkedList:0x00007fe4e1837200>
load factor: 0.4166666666666667

insert hash { "Star Wars: Return of the Jedi", "Number Six" }
-
-
#<LinkedList:0x00007fe4e1837458>
#<LinkedList:0x00007fe4e1837390>
#<LinkedList:0x00007fe4e18372c8>
-
#<LinkedList:0x00007fe4e1837548>
-
-
-
-
#<LinkedList:0x00007fe4e1837200>
load factor: 0.5








eduardos-MBP:separate_chaining eduardolowensohn$ ruby print.rb
insert hash { "Star Wars: The Phantom Menace", "Number One" }
#<LinkedList:0x00007fe5c5876628>
-
-
-
-
-
load factor: 0.16666666666666666

insert hash { "Star Wars: Attack of the Clones", "Number Two" }
#<LinkedList:0x00007fe5c5876628>
-
-
#<LinkedList:0x00007fe5c5875e08>
-
-
load factor: 0.3333333333333333

insert hash { "Star Wars: Revenge of the Sith", "Number Three" }
#<LinkedList:0x00007fe5c5876628>
-
-
#<LinkedList:0x00007fe5c5875e08>
-
#<LinkedList:0x00007fe5c5875778>
load factor: 0.5

insert hash { "Star Wars: A New Hope", "Number Four" }
#<LinkedList:0x00007fe5c5876628>
-
-
#<LinkedList:0x00007fe5c5875e08>
#<LinkedList:0x00007fe5c58750c0>
#<LinkedList:0x00007fe5c5875778>
load factor: 0.6666666666666666

insert hash { "Star Wars: The Empire Strikes Back", "Number Five" }
-
-
#<LinkedList:0x00007fe5c5874738>
#<LinkedList:0x00007fe5c5874620>
#<LinkedList:0x00007fe5c5874508>
-
#<LinkedList:0x00007fe5c5874828>
-
-
-
-
#<LinkedList:0x00007fe5c5874418>
load factor: 0.4166666666666667

insert hash { "Star Wars: Return of the Jedi", "Number Six" }
-
-
#<LinkedList:0x00007fe5c5874738>
#<LinkedList:0x00007fe5c5874620>
#<LinkedList:0x00007fe5c5874508>
-
#<LinkedList:0x00007fe5c5874828>
-
-
-
-
#<LinkedList:0x00007fe5c5874418>
load factor: 0.5




Answers: 

Cucko hashing which is an open addressing solution. It use 2 or more hashing functions where the pair key/value 
could be in 2 or more locations. If the first index reult in a collision during insertion,
then the key is re-hashed with the second hash function to map it to another bucket. If all hash
functions areare used and there still a collision, then the key it collided with is removed to make space
for the new key, and the old key is re-hashed with one of the other hash functions, which maps it to another
bucket.


Hopscotch hashing

Hopscotch hashing combines cuckoo hashing and linear probing. This algorithm is well defined
and work well for resizable concurrent hash table  when the load factor is bellow 0.9. 
The hopscotch hashing algorithm works by defining a neighborhood of 
buckets near the original hashed bucket, where a given entry is always
found. Thus, search is limited to the number of entries in this
neighborhood, which is logarithmic in the worst case, constant 
on average, and with proper alignment of the neighborhood 
typically requires one cache miss. When inserting an entry, one  first attempts to add it to a 
bucket in the neighborhood. 
However, if all buckets in this neighborhood are occupied,
the algorithm traverses buckets in sequence until an open 
slot (an unoccupied bucket) is found (as in linear probing).
At that point, since the empty bucket is outside the neighborhood,
items are repeatedly displaced in a sequence of hops.
(This is similar to cuckoo hashing, but with the difference 
that in this case the empty slot is being moved into the neighborhood,
instead of items being moved out with the hope of
eventually finding an empty slot.) Each hop brings the open
slot closer to the original neighborhood, without invalidating
the neighborhood property of any of the buckets along the way.
In the end, the open slot has been moved into the neighborhood,
and the entry being inserted can be added to it.


Coalesced hashing
A hybrid of chaining and open addressing, coalesced hashing links together 
chains of nodes within the table itself. Like open addressing, it 
achieves space usage and cache advantages over
chaining. 
Unlike chaining, it cannot have more elements than table slots.

Coalesced hashing is a collision avoidance technique when there
is a fixed sized data. It is a combination of both Separate
chaining and Open addressing. It uses the concept of Open 
Addressing(linear probing) to find first empty place for
colliding element from the bottom of the hash table and
the concept of Separate Chaining to link the colliding
elements to each other through pointers. The hash 
function used is h=(key)%(total number of keys).
Inside the hash table, each node has three fields:

h(key): The value of hash function for a key.
Data: The key itself.
Next: The link to the next colliding elements.

I would create a kind of separate_chaining hashing where the next collision will be added to a 
linked_list, with the difference to use a table to save the hash function of the collied key so dont repat that key 
until the next space is found, using a second created hash, then retrieve the hash function from the table, and
create another key, compare if there is not a collision use it and delete the data from the table.
if there are more collisions from the same key, use another key and if the 2 keys have collisions, save  the
second  hash function to the table, rey the first one if not the second and so on. The advantage is to re use one 
of the keys used before is not to spend time to hash another key value.


